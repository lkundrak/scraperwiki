from twisted.internet import protocol, utils, reactor
from twisted.web.client import Agent, ResponseDone
from twisted.internet.defer import succeed, Deferred
from twisted.internet.defer import Deferred
from twisted.internet.error import ProcessDone

import sys
import os
import datetime
import time
import uuid
import urllib, urlparse

try:    import json
except: import simplejson as json

def jstime(dt):
    return str(1000*int(time.mktime(dt.timetuple()))+dt.microsecond/1000)

# used for the process of direct connection to the controller through a socket
nodecontrollername = None
nodecontrollerhost = None
nodecontrollerport = None
def SetControllerHost(config):
    global nodecontrollername
    global nodecontrollerhost
    global nodecontrollerport
    umls = config.get('twister', 'umllist').split(',')
    nodecontrollername = umls[0]
    # TODO: This needs to be a list
    nodecontrollerhost = config.get(nodecontrollername, 'host')
    nodecontrollerport = config.getint(nodecontrollername, 'via')


class spawnRunner(protocol.ProcessProtocol):
    def __init__(self, client, code, logger):
        self.client = client
        self.code = code
        self.runID = None
        self.umlname = ''
        self.buffer = ''
        self.logger = logger
        self.style = "OldSpawnRunner"
        self.httpheaders = [ ]
        self.httpheadersdone = False
        
    def connectionMade(self):
        self.logger.debug("Starting run "+self.style)
        if self.style == "OldSpawnRunner":
            self.transport.write(self.code)
            self.transport.closeStdin()
    
    # called when the connection to the controntroller is opened
    def gotcontrollerconnectionprotocol(self, controllerconnection):
        controllerconnection.srunner = self
        self.controllerconnection = controllerconnection

            # generate the header element that is normally generated by dispatcher, 
            # which should in future be made by the node-controller
        json_msg = json.dumps({'message_type': 'executionstatus', 'content': 'startingrun', 'runID': self.jdata["runid"], 'uml': "directcontroller %s"%nodecontrollername})
        self.outReceived(json_msg+'\n')
        
            # send the data into the controller including all the code it should run
        sdata = json.dumps(self.jdata)
        self.logger.debug("sending: "+sdata)
        controllerconnection.transport.write('POST /Execute HTTP/1.0\r\n')
        controllerconnection.transport.write('Content-Length: %s\r\n' % len(sdata))
        controllerconnection.transport.write('Content-Type: text/json\r\n')
        controllerconnection.transport.write('Connection: close\r\n')
        controllerconnection.transport.write("\r\n")
        controllerconnection.transport.write(sdata)

    # messages from the UML
    def outReceived(self, data):
        self.logger.debug("runner to client# %d %s" % (self.client.clientnumber, data[:180]))
            # although the client can parse the records itself, it is necessary to split them up here correctly so that this code can insert its own records into the stream.
        lines  = (self.buffer+data).split("\n")
        self.buffer = lines.pop(-1)  # usually an empty
        
        for line in lines:
            # the old system returned no httpheaders
            # when the new system starts functioning it prob won't have headers either
            if not self.httpheadersdone and not self.httpheaders and line and line[0] == "{":
                self.httpheadersdone = True
            if not self.httpheadersdone:
                if line == "":
                    self.httpheadersdone = True
                    continue
                mheader = re.match("(.*?):\s*(.*)", line)
                if not mheader:
                    self.logger.error("Bad header: "+str([line]))
                self.httpheaders.append((mheader.group(1), mheader.group(2)))
                continue

            if not self.runID:  # intercept the first record to record its state and add in further data
                try:
                    parsed_data = json.loads(line.strip("\r"))
                except ValueError:
                    self.logger.error("Bad JSON: "+str([line]))
                    raise
                if type(parsed_data) != dict:
                    self.logger.error("JSON should be dict: "+str(parsed_data))
                
                if parsed_data.get('message_type') == 'executionstatus' and parsed_data.get('content') == 'startingrun':
                    self.runID = parsed_data.get('runID')
                    self.umlname = parsed_data.get('uml')
                    parsed_data['chatname'] = self.client.chatname
                    parsed_data['nowtime'] = jstime(datetime.datetime.now())
                    line = json.dumps(parsed_data)  # inject values into the field
            self.client.writeall(line)

        # could move into a proper function in the client once slimmed down slightly
    def processEnded(self, reason):
        self.client.processrunning = None

        sreason = str([reason])
        if sreason == "[<twisted.python.failure.Failure <class 'twisted.internet.error.ProcessDone'>>]":
            sreason = ""  # seems difficult to find the actual class type to compare with, but get rid of this "error" that really isn't an error
        elif sreason == "[<twisted.python.failure.Failure <class 'twisted.internet.error.ConnectionDone'>>]":
            sreason = ""  # seems difficult to find the actual class type to compare with, but get rid of this "error" that really isn't an error

        # other errors (eg connection lost) could put more useful errors into the client
        self.logger.debug("run process %s ended client# %d %s" % (self.client.clienttype, self.client.clientnumber, sreason))
    
        self.client.writeall(json.dumps({'message_type':'executionstatus', 'content':'runfinished', 'contentextra':sreason}))
        
        if self.client.clienttype == "editing":
            self.client.factory.notifyMonitoringClients(self.client)
        elif self.client.clienttype == "scheduledrun":
            self.client.scheduledrunmessageloophandler.schedulecompleted()
            self.client.factory.scheduledruncomplete(self.client, reason.type==ProcessDone)

    def controllerconnectionrequestFailure(self, failure):
        self.logger.info("controllerconnectionrequest failure received "+str(failure))


# simply ciphers through the two functions
class ControllerConnectionProtocol(protocol.Protocol):
    def connectionLost(self, reason):
        #self.srunner.logger.debug("*** controller socket connection lost: "+str(reason))
        self.srunner.processEnded(reason)
        
    def dataReceived(self, data):
        #self.srunner.logger.debug("*** controller socket connection data: "+data)
        self.srunner.outReceived(data)


clientcreator = protocol.ClientCreator(reactor, ControllerConnectionProtocol)



# this is the new way that totally bypasses the dispatcher.  
# we reuse the spawnRunner class only for its user defined functions, not its processprotocol functions!
def MakeSocketRunner(scrapername, guid, language, urlquery, username, code, client, logger, beta_user, attachables, rev):
    srunner = spawnRunner(client, code, logger)  # reuse this class and its functions

    jdata = { }
    jdata["code"] = code.replace('\r', '')
    jdata["cpulimit"] = 80
    jdata["draft"] = (not username)
    jdata["username"] = username   # comes through when done with stimulate_run, and we can use this for the dataproxy permissions (whether it can add to the attachables list)
    jdata["language"] = language
    jdata["scraperid"] = guid
    jdata["urlquery"] = urlquery
    jdata["scrapername"] = scrapername
    jdata["beta_user"] = beta_user
    jdata["attachables"] = attachables
    jdata["rev"] = rev

    # invent the runid (should actually
    jdata["runid"] = '%.6f_%s' % (time.time(), uuid.uuid4())
    if jdata.get("draft"):
       jdata["runid"] = "draft|||%s" % jdata["runid"]
    #logger.info(str(jdata))
    
    srunner.jdata = jdata
    srunner.style = "NewSpawnRunner"
    srunner.pid = "NewSpawnRunner"  # for the kill_run function

    deferred = clientcreator.connectTCP(nodecontrollerhost, nodecontrollerport)
    deferred.addCallbacks(srunner.gotcontrollerconnectionprotocol, srunner.controllerconnectionrequestFailure)

    return srunner
    

def MakeRunner(scrapername, guid, language, urlquery, username, code, client, logger, beta_user, attachables, rev):
    # Here for historical reasons - send everyone to the node controller host for now (although we may
    # add more in future)
    return MakeSocketRunner(scrapername, guid, language, urlquery, username, code, client, logger, beta_user, attachables, rev)
